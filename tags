!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/lugot/documents/university/master/thesis/code/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	/p5.9.20210905.0/
A	include/problem.h	/^    SparseMatrix A;$/;"	m	class:Problem	typeref:typename:SparseMatrix
CmdLineParser	scripts_TOFIX/profiler.py	/^class CmdLineParser(object):$/;"	c
Condition	include/step.h	/^    enum class Mode { None, Deflect, Condition, Hybrid };$/;"	e	enum:Step::Mode
Conditional	include/subgradient.h	/^    enum class DirectionStatus { Deflected, Conditional };$/;"	e	enum:Subgradient::DirectionStatus
Cplex	include/cplex.h	/^    Cplex(){};$/;"	f	class:Cplex
Cplex	include/cplex.h	/^    explicit Cplex(const std::string& model_name) { importModel(model_name); }$/;"	f	class:Cplex
Cplex	include/cplex.h	/^class Cplex {$/;"	c
Cplex	src/cplex.cc	/^Cplex::Cplex(const Cplex& other) {$/;"	f	class:Cplex
DELIM	src/globals.cc	/^char DELIM = ',';$/;"	v	typeref:typename:char
Decreasing	include/subgradient.h	/^    enum class ObjectiveStatus { MonotoneIncreasing, Increasing, Decreasing };$/;"	e	enum:Subgradient::ObjectiveStatus
Deflect	include/step.h	/^    enum class Mode { None, Deflect, Condition, Hybrid };$/;"	e	enum:Step::Mode
Deflected	include/subgradient.h	/^    enum class DirectionStatus { Deflected, Conditional };$/;"	e	enum:Subgradient::DirectionStatus
DirectionStatus	include/subgradient.h	/^    enum class DirectionStatus { Deflected, Conditional };$/;"	g	class:Subgradient
EPS	include/globals.h	/^#define EPS /;"	d
EPS_MONOTONICITY	include/globals.h	/^#define EPS_MONOTONICITY /;"	d
EQUAL	include/problem.h	/^    enum Sense { GREATER, EQUAL, LESS };$/;"	e	enum:Problem::Sense
EXTRA	src/globals.cc	/^bool EXTRA = false;$/;"	v	typeref:typename:bool
EmptyInstance	include/cplex.h	/^        EmptyInstance,$/;"	e	enum:Cplex::SolutionStatus
Error	include/cplex.h	/^        Error,$/;"	e	enum:Cplex::SolutionStatus
Feasible	include/cplex.h	/^        Feasible,$/;"	e	enum:Cplex::SolutionStatus
GREATER	include/problem.h	/^    enum Sense { GREATER, EQUAL, LESS };$/;"	e	enum:Problem::Sense
HARD_LAMBDA_TRESHOLD	include/globals.h	/^#define HARD_LAMBDA_TRESHOLD /;"	d
HIGHEPS	include/globals.h	/^#define HIGHEPS /;"	d
Hybrid	include/step.h	/^    enum class Mode { None, Deflect, Condition, Hybrid };$/;"	e	enum:Step::Mode
IGNORETIMELIMIT	src/globals.cc	/^int IGNORETIMELIMIT = 0;$/;"	v	typeref:typename:int
IMHERE	include/globals.h	/^#define IMHERE /;"	d
IMHERE2	include/globals.h	/^#define IMHERE2 /;"	d
INCLUDE_CPLEX_H_	include/cplex.h	/^#define INCLUDE_CPLEX_H_$/;"	d
INCLUDE_GLOBALS_H_	include/globals.h	/^#define INCLUDE_GLOBALS_H_$/;"	d
INCLUDE_LOGLINE_H_	include/logline.h	/^#define INCLUDE_LOGLINE_H_$/;"	d
INCLUDE_PROBLEM_H_	include/problem.h	/^#define INCLUDE_PROBLEM_H_$/;"	d
INCLUDE_SPARSE_MATRIX_H_	include/sparse_matrix.h	/^#define INCLUDE_SPARSE_MATRIX_H_$/;"	d
INCLUDE_SPARSE_VECTOR_H_	include/sparse_vector.h	/^#define INCLUDE_SPARSE_VECTOR_H_$/;"	d
INCLUDE_STEP_H_	include/step.h	/^#define INCLUDE_STEP_H_$/;"	d
INCLUDE_SUBGRADIENT_H_	include/subgradient.h	/^#define INCLUDE_SUBGRADIENT_H_$/;"	d
INF	include/globals.h	/^#define INF /;"	d
ITERINFO	src/globals.cc	/^int ITERINFO = 2e9;$/;"	v	typeref:typename:int
Increasing	include/subgradient.h	/^    enum class ObjectiveStatus { MonotoneIncreasing, Increasing, Decreasing };$/;"	e	enum:Subgradient::ObjectiveStatus
Infeasible	include/cplex.h	/^        Infeasible,$/;"	e	enum:Cplex::SolutionStatus
InfeasibleOrUnbounded	include/cplex.h	/^        InfeasibleOrUnbounded,$/;"	e	enum:Cplex::SolutionStatus
LESS	include/problem.h	/^    enum Sense { GREATER, EQUAL, LESS };$/;"	e	enum:Problem::Sense
LOGGING	src/globals.cc	/^bool LOGGING = false;$/;"	v	typeref:typename:bool
LOWERBOUND	include/globals.h	/^#define LOWERBOUND /;"	d
LogLine	include/logline.h	/^    LogLine() {$/;"	f	class:LogLine
LogLine	include/logline.h	/^    LogLine(char delim, bool fancy) {$/;"	f	class:LogLine
LogLine	include/logline.h	/^class LogLine {$/;"	c
MAXITER	src/globals.cc	/^int MAXITER = 100;$/;"	v	typeref:typename:int
MAX_NITERSTUCKED1	include/globals.h	/^#define MAX_NITERSTUCKED1 /;"	d
MAX_NITERSTUCKED2	include/globals.h	/^#define MAX_NITERSTUCKED2 /;"	d
MU_MAX	include/globals.h	/^#define MU_MAX /;"	d
MU_MIN	include/globals.h	/^#define MU_MIN /;"	d
Mode	include/step.h	/^    enum class Mode { None, Deflect, Condition, Hybrid };$/;"	g	class:Step
ModelChanged	include/cplex.h	/^        ModelChanged,$/;"	e	enum:Cplex::SolutionStatus
MonotoneIncreasing	include/subgradient.h	/^    enum class ObjectiveStatus { MonotoneIncreasing, Increasing, Decreasing };$/;"	e	enum:Subgradient::ObjectiveStatus
NOTMONOTIME	include/globals.h	/^#define NOTMONOTIME /;"	d
NeverSolved	include/cplex.h	/^        NeverSolved,$/;"	e	enum:Cplex::SolutionStatus
None	include/step.h	/^    enum class Mode { None, Deflect, Condition, Hybrid };$/;"	e	enum:Step::Mode
ObjectiveStatus	include/subgradient.h	/^    enum class ObjectiveStatus { MonotoneIncreasing, Increasing, Decreasing };$/;"	g	class:Subgradient
Optimal	include/cplex.h	/^        Optimal,$/;"	e	enum:Cplex::SolutionStatus
P	include/globals.h	/^#define P /;"	d
Problem	include/problem.h	/^class Problem {$/;"	c
Problem	src/problem.cc	/^Problem::Problem(const Cplex& cinst) {$/;"	f	class:Problem
SLOPE_MIN	include/globals.h	/^#define SLOPE_MIN /;"	d
SOFT_LAMBDA_MAXLIFE	include/globals.h	/^#define SOFT_LAMBDA_MAXLIFE /;"	d
SOFT_LAMBDA_TRESHOLD	include/globals.h	/^#define SOFT_LAMBDA_TRESHOLD /;"	d
STUCKTHRESHOLD	include/globals.h	/^#define STUCKTHRESHOLD /;"	d
STUCKTIME	include/globals.h	/^#define STUCKTIME /;"	d
Sense	include/problem.h	/^    enum Sense { GREATER, EQUAL, LESS };$/;"	g	class:Problem
SolutionStatus	include/cplex.h	/^    enum class SolutionStatus {$/;"	g	class:Cplex
SparseMatrix	include/sparse_matrix.h	/^class SparseMatrix {$/;"	c
SparseMatrix	src/sparse_matrix.cc	/^SparseMatrix::SparseMatrix(int nrows, int ncols) {$/;"	f	class:SparseMatrix
SparseVector	include/sparse_vector.h	/^    SparseVector(const SparseVector& x) {$/;"	f	class:SparseVector
SparseVector	include/sparse_vector.h	/^    explicit SparseVector(int size) { this->size = size; }$/;"	f	class:SparseVector
SparseVector	include/sparse_vector.h	/^class SparseVector {$/;"	c
SparseVector	src/sparse_vector.cc	/^SparseVector::SparseVector(Eigen::SparseVector<double> x) {$/;"	f	class:SparseVector
Step	include/step.h	/^class Step {$/;"	c
Step	src/step.cc	/^Step::Step(const Problem& lp, Mode mode) {$/;"	f	class:Step
Subgradient	include/subgradient.h	/^class Subgradient {$/;"	c
Subgradient	src/subgradient.cc	/^Subgradient::Subgradient() {$/;"	f	class:Subgradient
TAU	include/step.h	/^    static const double TAU;$/;"	m	class:Step	typeref:typename:const double
TAU	src/step.cc	/^const double Step::TAU = 1.5;$/;"	m	class:Step	typeref:typename:const double
TIMILIMIT	src/globals.cc	/^int TIMILIMIT = -1;$/;"	v	typeref:typename:int
UPPERBOUND	src/globals.cc	/^int UPPERBOUND = 20000;$/;"	v	typeref:typename:int
Unbounded	include/cplex.h	/^        Unbounded,$/;"	e	enum:Cplex::SolutionStatus
Unknown	include/cplex.h	/^        Unknown,$/;"	e	enum:Cplex::SolutionStatus
VERBOSE	src/globals.cc	/^bool VERBOSE = false;$/;"	v	typeref:typename:bool
VTV_EPSILON	include/globals.h	/^#define VTV_EPSILON /;"	d
VTV_LIM1	include/globals.h	/^#define VTV_LIM1 /;"	d
VTV_LIM2	include/globals.h	/^#define VTV_LIM2 /;"	d
VTV_MAX	include/globals.h	/^#define VTV_MAX /;"	d
VTV_VBAR	include/globals.h	/^#define VTV_VBAR /;"	d
WINSIZE	include/globals.h	/^#define WINSIZE /;"	d
__anon73df82680102	src/subgradient.cc	/^                                 [&lp](const std::pair<int, double>& p) {$/;"	f	function:Subgradient::project	file:
__anonb75b374c0102	src/step.cc	/^                       [this, u](const std::pair<int, double>& p) {$/;"	f	function:Step::feasibilize	file:
__anonb99be2300102	src/sparse_vector.cc	/^                              [tollerance](const std::pair<int, double>& p) {$/;"	f	function:SparseVector::prune	file:
__anonb99be2300202	src/sparse_vector.cc	/^                          [](const std::pair<int, double>& p, int target) {$/;"	f	function:SparseVector::isZero	file:
__init__	scripts_TOFIX/profiler.py	/^    def __init__(self):$/;"	m	class:CmdLineParser
a	scripts_TOFIX/schemes.py	/^a = a.drop([8], axis=1)$/;"	v
a	scripts_TOFIX/schemes.py	/^a = pd.read_csv("schemes", header=None)$/;"	v
addOption	scripts_TOFIX/profiler.py	/^    def addOption(self, *args, **kwargs):$/;"	m	class:CmdLineParser
addRow	src/sparse_matrix.cc	/^void SparseMatrix::addRow($/;"	f	class:SparseMatrix	typeref:typename:void
alpha	include/subgradient.h	/^    double alpha;$/;"	m	class:Subgradient	typeref:typename:double
b	include/problem.h	/^    SparseVector c, b;$/;"	m	class:Problem	typeref:typename:SparseVector
b	scripts_TOFIX/schemes.py	/^b = pd.DataFrame(columns=list(range(8)))$/;"	v
blue	scripts_TOFIX/coolprofiler.py	/^blue = (0, 191, 255)$/;"	v
blue	scripts_TOFIX/coolprofiler.py	/^blue = (0.0, 0.749, 1.0)$/;"	v
blue	scripts_TOFIX/coolprofilermu.py	/^blue = (0, 191, 255)$/;"	v
blue	scripts_TOFIX/coolprofilermu.py	/^blue = (0.0, 0.749, 1.0)$/;"	v
blue	scripts_TOFIX/coolprofilertriple.py	/^blue = (0, 191, 255)$/;"	v
blue	scripts_TOFIX/coolprofilertriple.py	/^blue = (0.0, 0.749, 1.0)$/;"	v
blue	scripts_TOFIX/plotter.py	/^blue = (0, 191, 255)$/;"	v
blue	scripts_TOFIX/plotter.py	/^blue = (0.0, 0.749, 1.0)$/;"	v
c	include/problem.h	/^    SparseVector c, b;$/;"	m	class:Problem	typeref:typename:SparseVector
colors	scripts_TOFIX/coolprofilermu.py	/^colors = {0.1: 'tab:red', 0.01: 'tab:purple', 0.001: 'tab:brown', 0.0001: 'tab:pink'}$/;"	v
colors	scripts_TOFIX/profiler.py	/^colors = ['tab:orange', 'tab:green', 'tab:blue', 'tab:red', 'tab:purple', 'tab:brown', 'tab:pink/;"	v
cols	include/sparse_matrix.h	/^    std::vector<SparseVector> rows, cols;$/;"	m	class:SparseMatrix	typeref:typename:std::vector<SparseVector>
constraintSense	src/problem.cc	/^Problem::Sense Problem::constraintSense(const IloRange& r) {$/;"	f	class:Problem	typeref:typename:Problem::Sense
cplex	include/cplex.h	/^    IloCplex cplex;$/;"	m	class:Cplex	typeref:typename:IloCplex
cplex_dual	scripts_TOFIX/plotter.py	/^    cplex_dual = []$/;"	v
cplex_dual	scripts_TOFIX/plotter.py	/^    cplex_dual = np.array(cplex_dual)$/;"	v
cplex_noiter	scripts_TOFIX/plotter.py	/^        cplex_noiter = True$/;"	v
cplex_noiter	scripts_TOFIX/plotter.py	/^    cplex_noiter = False$/;"	v
cplex_time	scripts_TOFIX/plotter.py	/^    cplex_time = np.arange(0, float(len(cplex_dual)))$/;"	v
cplex_timesolve	scripts_TOFIX/plotter.py	/^    cplex_timesolve = int(lines[-2].split()[1])$/;"	v
d	include/subgradient.h	/^    SparseVector u, s, d, x;$/;"	m	class:Subgradient	typeref:typename:SparseVector
dashes	scripts_TOFIX/profiler.py	/^dashes = ['-',  # solid line$/;"	v
data	include/logline.h	/^    std::vector<std::string> data;$/;"	m	class:LogLine	typeref:typename:std::vector<std::string>
data	include/sparse_vector.h	/^    std::vector<std::pair<int, double>> data;$/;"	m	class:SparseVector	typeref:typename:std::vector<std::pair<int,double>>
defLW	scripts_TOFIX/profiler.py	/^defLW = 1.2  # default line width$/;"	v
defMS	scripts_TOFIX/profiler.py	/^defMS = 7  # default marker size$/;"	v
delete_ext	scripts_TOFIX/plotter.py	/^def delete_ext(filename):$/;"	f
delim	include/logline.h	/^    char delim;$/;"	m	class:LogLine	typeref:typename:char
delta	include/step.h	/^    double delta;$/;"	m	class:Step	typeref:typename:double
delta	include/subgradient.h	/^    double lambda, mu, delta;$/;"	m	class:Subgradient	typeref:typename:double
deltaBelgachem	src/step.cc	/^double Step::deltaBelgachem(const SparseVector& d, const SparseVector& s) {$/;"	f	class:Step	typeref:typename:double
deltaCamerini	src/step.cc	/^double Step::deltaCamerini(const SparseVector& d, const SparseVector& s) {$/;"	f	class:Step	typeref:typename:double
deltaSherali	src/step.cc	/^double Step::deltaSherali(const SparseVector& d, const SparseVector& s) {$/;"	f	class:Step	typeref:typename:double
df	scripts_TOFIX/coolprofiler.py	/^df = pd.read_csv(sys.argv[1])$/;"	v
df1	scripts_TOFIX/coolprofilermu.py	/^    df1 = pd.read_csv("mu" + str(mu))$/;"	v
df1	scripts_TOFIX/coolprofilertriple.py	/^df1 = pd.read_csv("new1")$/;"	v
df2	scripts_TOFIX/coolprofilertriple.py	/^df2 = pd.read_csv("new2")$/;"	v
df3	scripts_TOFIX/coolprofilertriple.py	/^df3 = pd.read_csv("new3")$/;"	v
directionInfeasible	src/subgradient.cc	/^Subgradient::DirectionStatus Subgradient::directionInfeasible($/;"	f	class:Subgradient	typeref:typename:Subgradient::DirectionStatus
dist	src/sparse_vector.cc	/^double SparseVector::dist(const SparseVector& x, const SparseVector& y) {$/;"	f	class:SparseVector	typeref:typename:double
dstar	include/subgradient.h	/^    SparseVector ustar, dstar, xstar;$/;"	m	class:Subgradient	typeref:typename:SparseVector
env	include/cplex.h	/^    IloEnv env;$/;"	m	class:Cplex	typeref:typename:IloEnv
equal	include/problem.h	/^    std::vector<bool> equal;$/;"	m	class:Problem	typeref:typename:std::vector<bool>
extra_lines	scripts_TOFIX/plotter.py	/^    extra_lines = 0 $/;"	v
extractConstraint	src/problem.cc	/^void Problem::extractConstraint(const IloRange& r, int row,$/;"	f	class:Problem	typeref:typename:void
f	include/subgradient.h	/^    double f, phi, phistar_UB, phibar;$/;"	m	class:Subgradient	typeref:typename:double
fancy	include/logline.h	/^    bool fancy;$/;"	m	class:LogLine	typeref:typename:bool
feasibilize	src/step.cc	/^void Step::feasibilize(SparseVector* g, const SparseVector& u) {$/;"	f	class:Step	typeref:typename:void
fstar	include/subgradient.h	/^    double phistar, gap, fstar;$/;"	m	class:Subgradient	typeref:typename:double
gap	include/subgradient.h	/^    double phistar, gap, fstar;$/;"	m	class:Subgradient	typeref:typename:double
getDelta	include/step.h	/^    double getDelta() { return delta; }$/;"	f	class:Step	typeref:typename:double
getSize	include/sparse_vector.h	/^    int getSize() { return this->size; }$/;"	f	class:SparseVector	typeref:typename:int
getStatus	include/step.h	/^    int getStatus() { return status; }$/;"	f	class:Step	typeref:typename:int
green	scripts_TOFIX/coolprofiler.py	/^green = (0.341, 0.804, 0.5)$/;"	v
green	scripts_TOFIX/coolprofiler.py	/^green = (87, 205, 128)$/;"	v
green	scripts_TOFIX/coolprofilermu.py	/^green = (0.341, 0.804, 0.5)$/;"	v
green	scripts_TOFIX/coolprofilermu.py	/^green = (87, 205, 128)$/;"	v
green	scripts_TOFIX/coolprofilertriple.py	/^green = (0.341, 0.804, 0.5)$/;"	v
green	scripts_TOFIX/coolprofilertriple.py	/^green = (87, 205, 128)$/;"	v
green	scripts_TOFIX/plotter.py	/^green = (0.341, 0.804, 0.5)$/;"	v
green	scripts_TOFIX/plotter.py	/^green = (87, 205, 128)$/;"	v
i	scripts_TOFIX/plotter.py	/^    i = 0$/;"	v
importModel	src/cplex.cc	/^void Cplex::importModel(const std::string& model_name) {$/;"	f	class:Cplex	typeref:typename:void
initialize	src/subgradient.cc	/^bool Subgradient::initialize(const Problem& lp,$/;"	f	class:Subgradient	typeref:typename:bool
instance_name	include/problem.h	/^    std::string instance_name;$/;"	m	class:Problem	typeref:typename:std::string
instances	scripts_TOFIX/plotter.py	/^instances = [delete_ext(f) for f in listdir(path) if isfile(join(path, f))]$/;"	v
instances	scripts_TOFIX/plotter.py	/^instances = list(set(instances))$/;"	v
isZero	src/sparse_vector.cc	/^bool SparseVector::isZero(int idx) const {$/;"	f	class:SparseVector	typeref:typename:bool
iszig1	include/subgradient.h	/^    bool iszig1, iszig2;$/;"	m	class:Subgradient	typeref:typename:bool
iszig2	include/subgradient.h	/^    bool iszig1, iszig2;$/;"	m	class:Subgradient	typeref:typename:bool
iterate	src/subgradient.cc	/^bool Subgradient::iterate(const Problem& lp, int k,$/;"	f	class:Subgradient	typeref:typename:bool
label	scripts_TOFIX/coolprofilermu.py	/^    label = "$mu_0 = " + str(mu) + "$"$/;"	v
lambda	include/subgradient.h	/^    double lambda, mu, delta;$/;"	m	class:Subgradient	typeref:typename:double
lb	include/problem.h	/^    std::vector<double> lb, ub;$/;"	m	class:Problem	typeref:typename:std::vector<double>
line	scripts_TOFIX/plotter.py	/^        line = line.split()$/;"	v
lines	scripts_TOFIX/plotter.py	/^        lines = f.readlines()$/;"	v
lines	scripts_TOFIX/plotter.py	/^    lines = []$/;"	v
log	include/cplex.h	/^    std::ofstream log;$/;"	m	class:Cplex	typeref:typename:std::ofstream
log	include/subgradient.h	/^    std::ofstream log;$/;"	m	class:Subgradient	typeref:typename:std::ofstream
lp	include/step.h	/^    Problem lp;$/;"	m	class:Step	typeref:typename:Problem
m	include/problem.h	/^    int m, n;$/;"	m	class:Problem	typeref:typename:int
main	scripts_TOFIX/profiler.py	/^def main():$/;"	f
main	src/main.cc	/^int main(int argc, char* argv[]) {$/;"	f	typeref:typename:int
markers	scripts_TOFIX/profiler.py	/^markers = ['+', 'x', 's', '^', 'o', 'd']$/;"	v
mean	scripts_TOFIX/schemes.py	/^    mean = np.mean(row)$/;"	v
mean_phis	include/subgradient.h	/^    std::vector<double> mean_phis = std::vector<double>(P);$/;"	m	class:Subgradient	typeref:typename:std::vector<double>
merge	src/sparse_vector.cc	/^SparseVector SparseVector::merge(const SparseVector& x, const SparseVector& y) {$/;"	f	class:SparseVector	typeref:typename:SparseVector
mode	include/step.h	/^    Mode mode;$/;"	m	class:Step	typeref:typename:Mode
mode	include/subgradient.h	/^    Step::Mode mode = Step::Mode::Hybrid;$/;"	m	class:Subgradient	typeref:typename:Step::Mode
model	include/cplex.h	/^    IloModel model;$/;"	m	class:Cplex	typeref:typename:IloModel
model_name	include/cplex.h	/^    std::string model_name;$/;"	m	class:Cplex	typeref:typename:std::string
mu	include/subgradient.h	/^    double lambda, mu, delta;$/;"	m	class:Subgradient	typeref:typename:double
muCaprara	src/subgradient.cc	/^double Subgradient::muCaprara(std::vector<double> phis, double mu) {$/;"	f	class:Subgradient	typeref:typename:double
muKarp	src/subgradient.cc	/^double Subgradient::muKarp(double phi, std::vector<double> phis, double mu) {$/;"	f	class:Subgradient	typeref:typename:double
mueval	src/subgradient.cc	/^double Subgradient::mueval(const Problem& lp, double mu,$/;"	f	class:Subgradient	typeref:typename:double
mus	scripts_TOFIX/coolprofilermu.py	/^mus = [0.01, 0.001, 0.0001]$/;"	v
n	include/problem.h	/^    int m, n;$/;"	m	class:Problem	typeref:typename:int
ncols	include/sparse_matrix.h	/^    int nrows, ncols;$/;"	m	class:SparseMatrix	typeref:typename:int
nnz	include/problem.h	/^    int nnz() { return b.nnz() + A.nnz(); }$/;"	f	class:Problem	typeref:typename:int
nnz	include/sparse_matrix.h	/^    int nnz() {$/;"	f	class:SparseMatrix	typeref:typename:int
nnz	include/sparse_vector.h	/^    int nnz() { return this->data.size(); }$/;"	f	class:SparseVector	typeref:typename:int
nonZeroes	src/sparse_vector.cc	/^int SparseVector::nonZeroes() { return this->data.size(); }$/;"	f	class:SparseVector	typeref:typename:int
norm	src/sparse_vector.cc	/^double SparseVector::norm(const SparseVector& x) {$/;"	f	class:SparseVector	typeref:typename:double
np	scripts_TOFIX/coolprofiler.py	/^import numpy as np$/;"	I	nameref:module:numpy
np	scripts_TOFIX/coolprofilermu.py	/^import numpy as np$/;"	I	nameref:module:numpy
np	scripts_TOFIX/coolprofilertriple.py	/^import numpy as np$/;"	I	nameref:module:numpy
np	scripts_TOFIX/plotter.py	/^import numpy as np$/;"	I	nameref:module:numpy
np	scripts_TOFIX/profiler.py	/^import numpy as np$/;"	I	nameref:module:numpy
np	scripts_TOFIX/schemes.py	/^import numpy as np$/;"	I	nameref:module:numpy
nrows	include/sparse_matrix.h	/^    int nrows, ncols;$/;"	m	class:SparseMatrix	typeref:typename:int
obj	include/cplex.h	/^    IloObjective obj;$/;"	m	class:Cplex	typeref:typename:IloObjective
operator *	src/sparse_matrix.cc	/^SparseVector SparseMatrix::operator*(const SparseVector& x) {$/;"	f	class:SparseMatrix	typeref:typename:SparseVector
operator *	src/sparse_vector.cc	/^SparseVector SparseVector::operator*(const SparseMatrix& A) {$/;"	f	class:SparseVector	typeref:typename:SparseVector
operator *	src/sparse_vector.cc	/^SparseVector SparseVector::operator*(double scalar) const {$/;"	f	class:SparseVector	typeref:typename:SparseVector
operator *	src/sparse_vector.cc	/^double SparseVector::operator*(const SparseVector& x) const {$/;"	f	class:SparseVector	typeref:typename:double
operator *=	src/sparse_vector.cc	/^SparseVector SparseVector::operator*=(double scalar) {$/;"	f	class:SparseVector	typeref:typename:SparseVector
operator +	src/sparse_vector.cc	/^SparseVector SparseVector::operator+(const SparseVector& x) const {$/;"	f	class:SparseVector	typeref:typename:SparseVector
operator +=	src/sparse_vector.cc	/^SparseVector SparseVector::operator+=(const SparseVector& x) {$/;"	f	class:SparseVector	typeref:typename:SparseVector
operator -	src/sparse_vector.cc	/^SparseVector SparseVector::operator-(const SparseVector& x) {$/;"	f	class:SparseVector	typeref:typename:SparseVector
operator -=	src/sparse_vector.cc	/^SparseVector SparseVector::operator-=(const SparseVector& x) {$/;"	f	class:SparseVector	typeref:typename:SparseVector
operator <	src/sparse_vector.cc	/^bool SparseVector::operator<(const SparseVector& x) {$/;"	f	class:SparseVector	typeref:typename:bool
operator <<	include/logline.h	/^    friend std::ostream& operator<<(std::ostream& os, const LogLine& line) {$/;"	f	typeref:typename:std::ostream &
operator <<	src/sparse_matrix.cc	/^std::ostream& operator<<(std::ostream& os, const SparseMatrix& m) {$/;"	f	typeref:typename:std::ostream &
operator <<	src/sparse_vector.cc	/^std::ostream& operator<<(std::ostream& os, const SparseVector& x) {$/;"	f	typeref:typename:std::ostream &
operator =	include/sparse_vector.h	/^    SparseVector operator=(const SparseVector& x) {$/;"	f	class:SparseVector	typeref:typename:SparseVector
operator ==	src/sparse_vector.cc	/^bool SparseVector::operator==(const SparseVector& x) const {$/;"	f	class:SparseVector	typeref:typename:bool
operator >	src/sparse_vector.cc	/^bool SparseVector::operator>(const SparseVector& x) {$/;"	f	class:SparseVector	typeref:typename:bool
operator >>	include/logline.h	/^    friend LogLine& operator>>(LogLine& line, bool b) {$/;"	f	typeref:typename:LogLine &
operator >>	include/logline.h	/^    friend LogLine& operator>>(LogLine& line, double d) {$/;"	f	typeref:typename:LogLine &
operator >>	include/logline.h	/^    friend LogLine& operator>>(LogLine& line, int i) {$/;"	f	typeref:typename:LogLine &
operator >>	include/logline.h	/^    friend LogLine& operator>>(LogLine& line, std::string str) {$/;"	f	typeref:typename:LogLine &
operator >>	include/logline.h	/^    friend LogLine& operator>>(LogLine& line, std::vector<std::string> v) {$/;"	f	typeref:typename:LogLine &
optimal	include/subgradient.h	/^    bool optimal = false;$/;"	m	class:Subgradient	typeref:typename:bool
orange	scripts_TOFIX/coolprofiler.py	/^orange = (1.0, 0.5, 0.314)$/;"	v
orange	scripts_TOFIX/coolprofiler.py	/^orange = (255, 127, 80)$/;"	v
orange	scripts_TOFIX/coolprofilermu.py	/^orange = (1.0, 0.5, 0.314)$/;"	v
orange	scripts_TOFIX/coolprofilermu.py	/^orange = (255, 127, 80)$/;"	v
orange	scripts_TOFIX/coolprofilertriple.py	/^orange = (1.0, 0.5, 0.314)$/;"	v
orange	scripts_TOFIX/coolprofilertriple.py	/^orange = (255, 127, 80)$/;"	v
orange	scripts_TOFIX/plotter.py	/^orange = (1.0, 0.5, 0.314)$/;"	v
orange	scripts_TOFIX/plotter.py	/^orange = (255, 127, 80)$/;"	v
parseArgs	scripts_TOFIX/profiler.py	/^    def parseArgs(self):$/;"	m	class:CmdLineParser
path	scripts_TOFIX/plotter.py	/^path = 'results'$/;"	v
pd	scripts_TOFIX/coolprofiler.py	/^import pandas as pd$/;"	I	nameref:module:pandas
pd	scripts_TOFIX/coolprofilermu.py	/^import pandas as pd$/;"	I	nameref:module:pandas
pd	scripts_TOFIX/coolprofilertriple.py	/^import pandas as pd$/;"	I	nameref:module:pandas
pd	scripts_TOFIX/plotter.py	/^import pandas as pd$/;"	I	nameref:module:pandas
pd	scripts_TOFIX/schemes.py	/^import pandas as pd$/;"	I	nameref:module:pandas
performStep	src/step.cc	/^std::pair<SparseVector, SparseVector> Step::performStep(const SparseVector& s,$/;"	f	class:Step	typeref:typename:std::pair<SparseVector,SparseVector>
phi	include/subgradient.h	/^    double f, phi, phistar_UB, phibar;$/;"	m	class:Subgradient	typeref:typename:double
phibar	include/subgradient.h	/^    double f, phi, phistar_UB, phibar;$/;"	m	class:Subgradient	typeref:typename:double
phis	include/subgradient.h	/^    std::vector<double> phis = std::vector<double>(P);$/;"	m	class:Subgradient	typeref:typename:std::vector<double>
phistar	include/subgradient.h	/^    double phistar, gap, fstar;$/;"	m	class:Subgradient	typeref:typename:double
phistar_UB	include/subgradient.h	/^    double f, phi, phistar_UB, phibar;$/;"	m	class:Subgradient	typeref:typename:double
plt	scripts_TOFIX/coolprofiler.py	/^import matplotlib.pyplot as plt$/;"	I	nameref:module:matplotlib.pyplot
plt	scripts_TOFIX/coolprofilermu.py	/^import matplotlib.pyplot as plt$/;"	I	nameref:module:matplotlib.pyplot
plt	scripts_TOFIX/coolprofilertriple.py	/^import matplotlib.pyplot as plt$/;"	I	nameref:module:matplotlib.pyplot
plt	scripts_TOFIX/plotter.py	/^import matplotlib.pyplot as plt$/;"	I	nameref:module:matplotlib.pyplot
plt	scripts_TOFIX/profiler.py	/^import matplotlib.pyplot as plt$/;"	I	nameref:module:matplotlib.pyplot
print_usage	src/main.cc	/^void print_usage() {$/;"	f	typeref:typename:void
project	src/subgradient.cc	/^void Subgradient::project(const Problem& lp, SparseVector* u) {$/;"	f	class:Subgradient	typeref:typename:void
prune	src/sparse_vector.cc	/^void SparseVector::prune(double tollerance) {$/;"	f	class:SparseVector	typeref:typename:void
push_back	include/sparse_vector.h	/^    void push_back(std::pair<int, double> p, double tollerance = 0.0) {$/;"	f	class:SparseVector	typeref:typename:void
readTable	scripts_TOFIX/profiler.py	/^def readTable(fp, delimiter):$/;"	f
red	scripts_TOFIX/coolprofiler.py	/^red = (0.804, 0.361, 0.361)$/;"	v
red	scripts_TOFIX/coolprofiler.py	/^red = (205, 92, 92)$/;"	v
red	scripts_TOFIX/coolprofilermu.py	/^red = (0.804, 0.361, 0.361)$/;"	v
red	scripts_TOFIX/coolprofilermu.py	/^red = (205, 92, 92)$/;"	v
red	scripts_TOFIX/coolprofilertriple.py	/^red = (0.804, 0.361, 0.361)$/;"	v
red	scripts_TOFIX/coolprofilertriple.py	/^red = (205, 92, 92)$/;"	v
red	scripts_TOFIX/plotter.py	/^red = (0.804, 0.361, 0.361)$/;"	v
red	scripts_TOFIX/plotter.py	/^red = (205, 92, 92)$/;"	v
rng	include/cplex.h	/^    IloRangeArray rng;$/;"	m	class:Cplex	typeref:typename:IloRangeArray
rows	include/sparse_matrix.h	/^    std::vector<SparseVector> rows, cols;$/;"	m	class:SparseMatrix	typeref:typename:std::vector<SparseVector>
s	include/subgradient.h	/^    SparseVector u, s, d, x;$/;"	m	class:Subgradient	typeref:typename:SparseVector
setDelim	include/logline.h	/^    void setDelim(char delim) {$/;"	f	class:LogLine	typeref:typename:void
setFancy	include/logline.h	/^    void setFancy(bool fancy) {$/;"	f	class:LogLine	typeref:typename:void
size	include/sparse_vector.h	/^    int size;$/;"	m	class:SparseVector	typeref:typename:int
small_instances_print	scripts_TOFIX/plotter.py	/^small_instances_print = []$/;"	v
solve	src/cplex.cc	/^bool Cplex::solve() {$/;"	f	class:Cplex	typeref:typename:bool
solve	src/subgradient.cc	/^void Subgradient::solve(const Problem& lp, double UB, double timelimit,$/;"	f	class:Subgradient	typeref:typename:void
solveSP	src/subgradient.cc	/^SparseVector Subgradient::solveSP(const Problem& lp, const SparseVector& u) {$/;"	f	class:Subgradient	typeref:typename:SparseVector
solveSP	src/subgradient.cc	/^SparseVector* Subgradient::solveSP(const Problem& lp, SparseVector* x,$/;"	f	class:Subgradient	typeref:typename:SparseVector *
solvetime	include/cplex.h	/^    double solvetime;$/;"	m	class:Cplex	typeref:typename:double
squaredNorm	src/sparse_vector.cc	/^double SparseVector::squaredNorm(const SparseVector& x) {$/;"	f	class:SparseVector	typeref:typename:double
status	include/cplex.h	/^    SolutionStatus status;$/;"	m	class:Cplex	typeref:typename:SolutionStatus
status	include/step.h	/^    int status;$/;"	m	class:Step	typeref:typename:int
subgr	scripts_TOFIX/plotter.py	/^    subgr = pd.read_csv("results\/" + instance + ".subgr_log")$/;"	v
subgr_dual	scripts_TOFIX/coolprofiler.py	/^subgr_dual = df["dual"]$/;"	v
subgr_dual	scripts_TOFIX/plotter.py	/^    subgr_dual = subgr["dual"]$/;"	v
subgr_dual1	scripts_TOFIX/coolprofilermu.py	/^    subgr_dual1 = df1["dual"]$/;"	v
subgr_dual1	scripts_TOFIX/coolprofilertriple.py	/^subgr_dual1 = df1["dual"]$/;"	v
subgr_dual2	scripts_TOFIX/coolprofilertriple.py	/^subgr_dual2 = df2["dual"]$/;"	v
subgr_dual3	scripts_TOFIX/coolprofilertriple.py	/^subgr_dual3 = df3["dual"]$/;"	v
subgr_noiter	scripts_TOFIX/plotter.py	/^        subgr_noiter = True$/;"	v
subgr_noiter	scripts_TOFIX/plotter.py	/^    subgr_noiter = False$/;"	v
subgr_time	scripts_TOFIX/plotter.py	/^    subgr_time = subgr["time"]$/;"	v
timelimitkill	src/subgradient.cc	/^bool timelimitkill(std::chrono::steady_clock::time_point begin,$/;"	f	typeref:typename:bool
toEigen	src/sparse_matrix.cc	/^Eigen::SparseMatrix<double> SparseMatrix::toEigen() const {$/;"	f	class:SparseMatrix	typeref:typename:Eigen::SparseMatrix<double>
toEigen	src/sparse_vector.cc	/^Eigen::SparseVector<double> SparseVector::toEigen() const {$/;"	f	class:SparseVector	typeref:typename:Eigen::SparseVector<double>
u	include/subgradient.h	/^    SparseVector u, s, d, x;$/;"	m	class:Subgradient	typeref:typename:SparseVector
ub	include/problem.h	/^    std::vector<double> lb, ub;$/;"	m	class:Problem	typeref:typename:std::vector<double>
ustar	include/subgradient.h	/^    SparseVector ustar, dstar, xstar;$/;"	m	class:Subgradient	typeref:typename:SparseVector
var	include/cplex.h	/^    IloNumVarArray var;$/;"	m	class:Cplex	typeref:typename:IloNumVarArray
varindexer	include/problem.h	/^    std::map<std::string, int> varindexer;$/;"	m	class:Problem	typeref:typename:std::map<std::string,int>
x	include/subgradient.h	/^    SparseVector u, s, d, x;$/;"	m	class:Subgradient	typeref:typename:SparseVector
xstar	include/subgradient.h	/^    SparseVector ustar, dstar, xstar;$/;"	m	class:Subgradient	typeref:typename:SparseVector
zero	include/subgradient.h	/^    const SparseVector zero = SparseVector(0);$/;"	m	class:Subgradient	typeref:typename:const SparseVector
zigzagg1	src/step.cc	/^bool Step::zigzagg1(const SparseVector& s, const SparseVector& d) {$/;"	f	class:Step	typeref:typename:bool
zigzagg2	src/step.cc	/^bool Step::zigzagg2(const SparseVector& s, const SparseVector& u,$/;"	f	class:Step	typeref:typename:bool
~Cplex	src/cplex.cc	/^Cplex::~Cplex() {$/;"	f	class:Cplex
~SparseVector	include/sparse_vector.h	/^    ~SparseVector() {}$/;"	f	class:SparseVector
